---
title: "Hands-on Exercise 02"
---

# **2Â Â Thematic Mapping and GeoVisualisation with R**

## 2.1 Overview

Thematic mapping uses symbols on maps to represent invisible or abstract data, such as population, crime rates, or housing prices. These values aren't naturally visible in the landscape but can be effectively communicated through visual representation.

Geovisualisation is the practice of turning spatial data into visuals to support exploration, analysis, and communication. It combines cartography, data visualization, and computer science to improve our understanding of geographic patterns.

In this chapter, we will learn how to create meaningful and accurate choropleth maps using the `tmap` package in R.

> **ğŸ’¡ Tip**: Always read the function description before using it. Understanding what it does can prevent mistakes and confusion.

## **2.2Â Getting Started**

In this hands-on exercise, the key R package use isÂ [**tmap**](https://cran.r-project.org/web/packages/tmap/)Â package in R. BesideÂ **tmap**Â package, five other R packages will be used. They are:

-   [**readr**](https://readr.tidyverse.org/)Â for importing delimited text file,

-   [**tidyr**](https://tidyr.tidyverse.org/)Â for tidying data,

-   [**dplyr**](https://dplyr.tidyverse.org/)Â for wrangling data and

-   [**sf**](https://cran.r-project.org/web/packages/sf/index.html)Â for handling geospatial data.

-   [**rvest**](https://rvest.tidyverse.org/)Â for scraping (or harvesting) data from web pages.

Among the five packages,Â **readr**,Â **tidyr**Â andÂ **dplyr**Â are part ofÂ **tidyverse**Â package.

The code chunk below will be used to install and load these packages in RStudio.

```{r}
pacman::p_load(sf, tmap, tidyverse, rvest)
```

Notice that, we only need to installÂ **tidyverse.**

## **2.3Â Importing Data into R**

### **2.3.1Â The Data**

Two datasets are used to construct the choropleth map:

-   **Master Plan 2019 Subzone Boundary (No Sea) \[KML\]**:\
    This is a **geospatial dataset** downloaded from [data.gov.sg](https://data.gov.sg). It provides the planning subzone boundaries of Singapore based on URA's Master Plan 2019. The geometry information in this file enables spatial visualization.

-   **Singapore Residents by Planning Area / Subzone, Age Group, Sex and Type of Dwelling, June 2024 \[CSV\]**:\
    This is an **aspatial dataset** from the Singapore Department of Statistics. Although it lacks coordinate data, it contains `PA` (Planning Area) and `SZ` (Subzone) fields. These fields can be used as unique keys to join with the spatial boundary file for georeferencing.

### **2.3.2Â Importing Geospatial Data into R**

The code chunk below uses theÂ *st_read()*Â function ofÂ **sf**Â package to importÂ `MP14_SUBZONE_WEB_PL`shapefile into R as a simple feature data frame calledÂ `mpsz`.

```{r}
mpsz <- st_read("data/geospatial/MasterPlan2019SubzoneBoundaryNoSeaKML.kml")
```

#### 2.3.2.1Â Tidying data

Function to extract values from the HTML description

```{r}
extract_kml_field <- function(html_text, field_name) {
  if (is.na(html_text) || html_text == "") return(NA_character_)
  
  page <- read_html(html_text)
  rows <- page %>% html_elements("tr")
  
  value <- rows %>%
    keep(~ html_text2(html_element(.x, "th")) == field_name) %>%
    html_element("td") %>%
    html_text2()
  
  if (length(value) == 0) NA_character_ else value
}
```

```{r}
mpsz <- mpsz %>%
  mutate(
    REGION_N = map_chr(Description, extract_kml_field, "REGION_N"),
    PLN_AREA_N = map_chr(Description, extract_kml_field, "PLN_AREA_N"),
    SUBZONE_N = map_chr(Description, extract_kml_field, "SUBZONE_N"),
    SUBZONE_C = map_chr(Description, extract_kml_field, "SUBZONE_C")
  ) %>%
  select(-Name, -Description) %>%
  relocate(geometry, .after = last_col())
```

Then,we can examine the content ofÂ `mpsz`Â by using the code chunk below.

```{r}
mpsz
```

::: {.callout-note title="ğŸ“’ Notice that only the first ten records will be displayed. Do you know why?"}
By default, when viewing a data frame or an `sf` object in R, only the first 10 records are displayed.\

This is done for performance and readability reasonsâ€”especially when the dataset contains hundreds or thousands of rows.\

To view more or all records, you can use functions like `View(mpsz)`, `print(mpsz, n = 50)`, or use `dplyr::slice()` to select specific rows.
:::

### **2.3.3Â Importing Attribute Data into R**

Next, we will importÂ *respopagesextod2024.csv*Â file into RStudio and save the file into an tibble dataframe calledÂ *popdata*.

The task will be performed by usingÂ *read_csv()*Â function ofÂ **readr**Â package as shown in the code chunk below.

```{r}
popdata <- read_csv("data/aspatial/respopagesextod2024.csv")
```

### **2.3.4Â Data Preparation**

Before a thematic map can be prepared, you are required to prepare a data table with year 2020 values. The data table should include the variables PA, SZ, YOUNG, ECONOMY ACTIVE, AGED, TOTAL, DEPENDENCY.

-   YOUNG: age group 0 to 4 until age groyup 20 to 24,

-   ECONOMY ACTIVE: age group 25-29 until age group 60-64,

-   AGED: age group 65 and above,

-   TOTAL: all age group, and

-   DEPENDENCY: the ratio between young and aged against economy active group

#### 2.3.4.1Â Data wrangling

The following data wrangling and transformation functions will be used:

-   *pivot_wider()*Â ofÂ **tidyr**Â package, and

-   *mutate()*,Â *filter()*,Â *group_by()*Â andÂ *select()*Â ofÂ **dplyr**Â package

```{r}
popdata2024 <- popdata %>%
  group_by(PA, SZ, AG) %>%
  summarise(`POP` = sum(`Pop`)) %>%
  ungroup()%>%
  pivot_wider(names_from=AG, 
              values_from=POP) %>%
  mutate(YOUNG = rowSums(.[3:6])
         +rowSums(.[12])) %>%
mutate(`ECONOMY ACTIVE` = rowSums(.[7:11])+
rowSums(.[13:15]))%>%
mutate(`AGED`=rowSums(.[16:21])) %>%
mutate(`TOTAL`=rowSums(.[3:21])) %>%  
mutate(`DEPENDENCY` = (`YOUNG` + `AGED`)
/`ECONOMY ACTIVE`) %>%
  select(`PA`, `SZ`, `YOUNG`, 
       `ECONOMY ACTIVE`, `AGED`, 
       `TOTAL`, `DEPENDENCY`)
```

#### 2.3.4.2Â Joining the attribute data and geospatial data

Before we can perform the georelational join, one extra step is required to convert the values in PA and SZ fields to uppercase. This is because the values of PA and SZ fields are made up of upper- and lowercase. On the other, hand the SUBZONE_N and PLN_AREA_N are in uppercase.

```{r}
popdata2024 <- popdata2024 %>%
  mutate_at(.vars = vars(PA, SZ), 
          .funs = list(toupper)) %>%
  filter(`ECONOMY ACTIVE` > 0)
```

Next,Â *left_join()*Â ofÂ **dplyr**Â is used to join the geographical data and attribute table using planning subzone name e.g.Â *SUBZONE_N*Â andÂ *SZ*Â as the common identifier.

```{r}
mpsz_pop2024 <- left_join(mpsz, popdata2024,
                          by = c("SUBZONE_N" = "SZ"))
```

*Left_join()*Â ofÂ **dplyr**Â package is used withÂ `mpsz`Â simple feature data frame as the left data table is to ensure that the output will be a simple features data frame.

```{r}
write_rds(mpsz_pop2024, "data/rds/mpsz_pop2024.rds")
```

ğŸ’¡ You need to create this folder structure first and then write it into the.rds file. One sentence can be added before writing: "dir.create("data/rds", recursive = TRUE, showWarnings = FALSE) "

## **2.4Â Choropleth Mapping Geospatial Data UsingÂ *tmap***

Choropleth mapping involves the symbolisation of enumeration units, such as countries, provinces, states, counties or census units, using area patterns or graduated colors. For example, a social scientist may need to use a choropleth map to portray the spatial distribution of aged population of Singapore by Master Plan 2014 Subzone Boundary.

Two approaches can be used to prepare thematic map usingÂ *tmap*, they are:

-   Plotting a thematic map quickly by usingÂ *qtm()*.

-   Plotting highly customisable thematic map by using tmap elements.

### **2.4.1Â Plotting a choropleth map quickly by usingÂ *qtm()***

The easiest and quickest to draw a choropleth map usingÂ **tmap**Â is usingÂ *qtm()*. It is concise and provides a good default visualisation in many cases.

The code chunk below will draw a cartographic standard choropleth map as shown below.

```{r}
tmap_mode("plot")
qtm(shp = mpsz_pop2024, 
    fill = "DEPENDENCY")
```

-   *tmap_mode()*Â with â€œplotâ€ option is used to produce a static map. For interactive mode, â€œviewâ€ option should be used.

-   *fill*Â argument is used to map the attribute (i.e.Â DEPENDENCY)

### **2.4.2Â Creating a choropleth map by usingÂ *tmap*â€™s elements**

Despite its usefulness of drawing a choropleth map quickly and easily, the disadvantge ofÂ *qtm()*Â is that it makes aesthetics of individual layers harder to control. To draw a high quality cartographic choropleth map as shown in the figure below,Â **tmap**â€™s drawing elements should be used.

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile", 
                n = 5,
                values = "brewer.blues"),
              fill.legend = tm_legend(
                title = "Dependency ratio")) +
  tm_title("Distribution of Dependency Ratio by planning subzone") +
  tm_layout(frame = TRUE) +
  tm_borders(fill_alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scalebar() +
  tm_grid(alpha =0.2) +
  tm_credits("Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\n and Population data from Department of Statistics DOS", 
             position = c("left", "bottom"))
```

#### 2.4.2.1Â Drawing a base map

The basic building block ofÂ **tmap**Â isÂ `tm_shape()`Â followed by one or more layer elemments such asÂ `tm_polygons()`,Â `tm_symbols()`,Â `tm_lines()`,Â `tm_raster()`Â andÂ `tm_text()`.

In the code chunk below,Â `tm_shape()`Â is used to define the input data (i.eÂ *mpsz_pop2024*) andÂ `tm_polygons()`Â is used to draw the planning subzone polygons

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons()
```

> ğŸ“’ **Note:** By default, it plots areas of polygons in light gray (gray85) and polygons borders in slightly dark gray (gray25).

#### 2.4.2.2Â Drawing a choropleth map usingÂ `tm_polygons()`

To draw a choropleth map showing the geographical distribution of a selected variable by planning subzone, we just need to assign the target variable such asÂ *Dependency*Â toÂ *tm_polygons()*.

```{r}
tm_shape(mpsz_pop2024)+
  tm_polygons(fill = "DEPENDENCY")
```

Things to learn fromÂ *tm_polygons()*:

-   The default interval binning used to draw the choropleth map is called â€œprettyâ€.

-   The default colour scheme used isÂ `blues3`Â of ColorBrewer.

-   By default, Missing value will be shaded in grey.

#### 2.4.2.3Â Drawing a choropleth map usingÂ *tm_fill()*Â and \*tm_border()\*\*

Actually,Â `tm_polygons()`Â is a wraper ofÂ `tm_fill()`Â andÂ `tm_border()`.Â `tm_fill()`Â shades the polygons by using the default colour scheme andÂ `tm_borders()`Â adds the borders of the polygon features onto the choropleth map.

The code chunk below draws a choropleth map by usingÂ `tm_fill()`Â alone.

```{r}
tm_shape(mpsz_pop2024)+
  tm_fill("DEPENDENCY")
```

Notice that the planning subzones are shared according to the respective dependecy values

To add the boundary of the planning subzones,Â `tm_borders()`Â will be used as shown in the code chunk below.

```{r}
tm_shape(mpsz_pop2024)+
  tm_fill("DEPENDENCY") +
  tm_borders()
```

Notice that light-gray border lines have been added on the choropleth map.

TheÂ `fill_alpha`Â argument is used to define transparency number between 0 (totally transparent) and 1 (not transparent). By default, the alpha value of the col is used (normally 1).

BesideÂ `fill_alpha`Â argument, there are three other arguments forÂ `tm_borders()`, they are:

-   `col`Â = border colour,

-   `lwd`Â = border line width. The default is 1, and

-   `lty`Â = border line type. The default is â€œsolidâ€.

```{r}
tm_shape(mpsz_pop2024)+
  tm_fill("DEPENDENCY") +
  tm_borders(col = "grey60",
             lwd = 0.1,
             lty = "dashed")
```

### **2.4.3Â Data classification methods ofÂ tmap**

Most choropleth maps employ some methods of data classification. The point of classification is to take a large number of observations and group them into data ranges or classes.

**tmap**Â provides a total ten data classification methods, namely:Â *fixed*,Â *sd*,Â *equal*,Â *pretty*Â (default),Â *quantile*,Â *kmeans*,Â *hclust*,Â *bclust*,Â *fisher*, andÂ *jenks*.

To define a data classification method, theÂ *style*Â argument ofÂ *tm_fill()*Â orÂ *tm_polygons()*Â will be used.

#### 2.4.3.1Â Plotting choropleth maps with built-in classification methods

The code chunk below shows a quantile data classification that used 5 classes.

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5)) +
  tm_borders(fill_alpha = 0.5)
```

In the code chunk below,Â *equal*Â data classification method is used.

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "equal",
                n = 5)) +
  tm_borders(fill_alpha = 0.5)
```

Notice that the distribution of quantile data classification method are more evenly distributed then equal data classification method.

![](images/clipboard-2761897374.png)

#### 2.4.3.2Â Plotting choropleth map with custome break

For all the built-in styles, the category breaks are computed internally. In order to override these defaults, the breakpoints can be set explicitly by means of theÂ `breaks`Â argument to theÂ `tm_scale_intervals()`. It is important to note that, inÂ **tmap**Â the breaks include a minimum and maximum. As a result, in order to end up with n categories, n+1 elements must be specified in theÂ `breaks`Â option (the values must be in increasing order).

Before we get started, it is always a good practice to get some descriptive statistics on the variable before setting the break points. Code chunk below will be used to compute and display the descriptive statistics ofÂ *DEPENDENCY*Â field.

```{r}
summary(mpsz_pop2024$DEPENDENCY)
```

With reference to the results above, we set break point at 0.60, 0.70, 0.80, and 0.90. In addition, we also need to include a minimum and maximum, which we set at 0 and 100. OurÂ `breaks`Â vector is thus c(0, 0.60, 0.70, 0.80, 0.90, 1.00)

Now, we will plot the choropleth map by using the code chunk below.

```{r}
tm_shape(mpsz_pop2024)+
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                breaks = c(0, 0.60, 0.70, 0.80, 0.90, 1.00))) +
  tm_borders(fill_alpha = 0.5)
```

### **2.4.4Â Colour Scheme**

**tmap**Â supports colour ramps either defined by the user or a set of predefined colour ramps from theÂ **RColorBrewer**Â package.

#### 2.4.4.1Â Using ColourBrewer palette

To change the colour, we assign the preferred colour toÂ *palette*Â argument ofÂ *values*Â as shown in the code chunk below.

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5,
                values = "brewer.greens")) +
  tm_borders(fill_alpha = 0.5)
```

Notice that the choropleth map is shaded in green.

To reverse the colour shading, add a â€œ-â€ prefix.

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5,
                values = "-brewer.greens")) +
  tm_borders(fill_alpha = 0.5)
```

Notice that the colour scheme has been reversed.

#### 2.4.4.2Â Cartographic Furniture

Beside map style,Â **tmap**Â also also provides arguments to draw other map furniture such as compass, scale bar and grid lines.

In the code chunk below,Â `tm_compass()`,Â `tm_scale_bar()`,Â `tm_grid()`Â andÂ `tm_credit()`Â are used to add compass, scale bar, grid lines and data sources onto the choropleth map.

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5)) +
  tm_borders(fill_alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scalebar() +
  tm_grid(lwd = 0.1, alpha = 0.2) +
  tm_credits("Source: data.gov.sg & singstat",
             position = c("left", "bottom"))
```

### **2.4.5Â Map Layout**

Map layout refers to the combination of all map elements into a cohensive map. It includes the map background, frame, typography, scale, aspect ratio, margins, and more.

We can customize the map layout using theÂ `tm_layout()`Â function. In this section, we cover the most often used arguments of this function using the dependency choropleth map as example.

#### 2.4.5.1Â Map Legend

InÂ **tmap**, severalÂ *legend*Â options are provided to change the placement, format and appearance of the legend.

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5),
              fill.legend = tm_legend(
                title = "Dependency ratio")) +
  tm_pos_auto_in() +
  tm_borders(fill_alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scalebar() +
  tm_grid(lwd = 0.1, alpha = 0.2) +
  tm_credits("Source: data.gov.sg & singstat",
             position = c("left", "bottom"))
```

#### 2.4.5.2Â Map style

**tmap**Â allows a wide variety of layout settings to be changed. They can be called by usingÂ *tmap_style()*.

The code chunk below shows theÂ *classic*Â style is used.

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5,
                values = "-brewer.greens")) + 
  tm_borders(fill_alpha = 0.5) + 
  tmap_style("natural")
```

To reset the default style, refer to the code: ''tmap_style("white")''

## **2.5Â Drawing Small Multiple Choropleth Maps**

**Small multiple maps**, also referred to asÂ **facet maps**, are composed of many maps arrange side-by-side, and sometimes stacked vertically. Small multiple maps enable the visualisation of how spatial relationships change with respect to another variable, such as time.

InÂ **tmap**, small multiple maps can be plotted in three ways:

-   by assigning multiple values to at least one of the asthetic arguments,

-   by creating multiple stand-alone maps withÂ *tmap_arrange()*, and

-   by defining a group-by variable inÂ *tm_facets()*.

### **2.5.1Â By assigning multiple values to at least one of the aesthetic arguments**

In this example, small multiple choropleth maps are created by assigning two variables to the visual variable (i.e.Â fill).

```{r}
tm_shape(mpsz_pop2024) + 
  tm_polygons(
    fill = c("YOUNG", "AGED"),
    fill.legend = 
      tm_legend(position = tm_pos_in(
        "right", "bottom")),
    fill.scale = tm_scale_intervals(
      style = "equal", 
      n = 5,
      values = "brewer.blues")) +
  tm_borders(fill_alpha = 0.5) +
  tmap_style("natural")
```

### **2.5.2Â By arrange multiples choropleth maps in a grid layout**

In this example, multiple choropleth maps are created andÂ `tmap_arrnage()`Â is used to arrnage them in a grid layout.

```{r}
youngmap <- tm_shape(mpsz_pop2024)+ 
  tm_polygons(fill = "YOUNG",
              fill.legend = tm_legend(
                position = tm_pos_in(
                  "right", "bottom"),
                  item.height = 0.8),
              fill.scale = tm_scale_intervals(
                style = "quantile", 
                values = "brewer.blues")) +
  tm_borders(fill_alpha = 0.5) +
  tm_title("Distribution of young population")
                
agedmap <- tm_shape(mpsz_pop2024)+ 
  tm_polygons(fill = "AGED",
              fill.legend = tm_legend(
                position = tm_pos_in(
                  "right", "bottom"),
                item.height = 0.8),
              fill.scale = tm_scale_intervals(
              style = "quantile", 
              values = "brewer.blues")) +
  tm_borders(fill_alpha = 0.5) +
  tm_title("Distribution of aged population")

tmap_arrange(youngmap, agedmap, asp=1, ncol=2)
```

### **2.5.3Â By defining a group-by variable inÂ *tm_facets()***

In this example, multiple small choropleth maps are created by usingÂ **tm_facets()**.

```{r}
tm_shape(mpsz_pop2024) +
  tm_fill(fill = "DEPENDENCY",
          fill.scale = tm_scale_intervals(
            style = "quantile",
            values = "brewer.blues")) + 
  tm_facets(by = "REGION_N",
            nrow = 2, 
            ncols = 3,
            free.coords=TRUE, 
            drop.units=TRUE) +
  tm_layout(legend.show = TRUE,
            title.position = c("center", "center"), 
            title.size = 20) +
  tm_borders(fill_alpha = 0.5)
```

## **2.6Â Mappping Spatial Object Meeting a Selection Criterion**

Instead of creating small multiple choropleth map, you can also useÂ `filter()`Â ofÂ **dplyr**Â package to select geographical area of interest and plot a choropleth map focus only on the selected region.

```{r}
mpsz_pop2024 %>%
  filter(REGION_N == "CENTRAL REGION") %>%
  tm_shape() +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile", 
                values = "brewer.greens"),
              fill.legend = tm_legend()) +
  tm_borders(fill_alpha = 0.5)
```

## **2.7Â Complementing Thematic Map with Statistical Chart**

Maps and statistical charts complement each other by visually representing different aspects of the same data, offering a more comprehensive understanding. Maps excel at showing spatial relationships and geographical patterns, while charts effectively display numerical data, trends, and comparisons. Combining both allows for a more insightful and engaging data narrative, especially when dealing with spatial data that also has quantifiable characteristics.

With tmap, statistical chart and be incorporate into the map visualisation by usingÂ `fill.chat`Â argument of map layers andÂ [**legend chart**](https://r-tmap.github.io/tmap/reference/tm_chart.html)Â feature as shown in the code chunk below.

```{r}
mpsz_pop2024 %>%
  filter(REGION_N == "CENTRAL REGION") %>%
  tm_shape() +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile", 
                values = "brewer.greens"),
              fill.legend = tm_legend(),
              fill.chart = tm_chart_box()) +
  tm_borders() +
  tm_layout(asp = 0.8)
```

In the code chunk below, We improve the visual representation further by highlighting and lebaling the outliers on the choropleth map.

```{r}
mpsz_selected <- mpsz_pop2024 %>%
  filter(REGION_N == "CENTRAL REGION")

stats <- boxplot.stats(mpsz_selected$DEPENDENCY)

outlier_vals <- stats$out

outlier_sf <- mpsz_selected[mpsz_selected$DEPENDENCY %in% outlier_vals, ]

tm_shape(mpsz_selected) +
  tm_polygons(fill = "DEPENDENCY",
          fill.scale = tm_scale_intervals(
            style = "quantile", 
            values = "brewer.blues"),
          fill.legend = tm_legend(),
          fill.chart = tm_chart_box()) +
  tm_borders(fill_alpha = 0.5) +
tm_shape(outlier_sf) +
  tm_borders(col = "red", lwd = 2) +
  tm_text("SUBZONE_N", col = "red", size = 0.7) +
  tm_layout(asp = 0.8)
```

## **2.8Â Creating Interactive Map**

Interactive maps let users actively explore and interact with the data they display. Unlike static maps, you can zoom in and out, pan across areas, click on locations for more information, and even work with data overlays or visualizationsâ€”making the experience more dynamic and informative. One of the great things about tmap is that it lets you switch easily between static and interactive maps usingÂ `tmap_mode()`, so you can choose the view that best suits your analysis.

By modifying the code chunk in sub-section 2.6, the code chunks below build an interactive map using:

```{r}
region_selected <- mpsz_pop2024 %>%
  filter(REGION_N == "CENTRAL REGION")
region_bbox <- st_bbox(region_selected)

stats <- boxplot.stats(region_selected$DEPENDENCY)
outlier_vals <- stats$out
outlier_sf <- region_selected[region_selected$DEPENDENCY %in% outlier_vals, ]

tmap_mode("view")
tm_shape(region_selected, 
         bbox = region_bbox) +
  tm_fill("DEPENDENCY",
          id = "SUBZONE_N",
          popup.vars = c(
            "Name" = "SUBZONE_N", 
            "Dependency" = "DEPENDENCY")) +
  tm_borders() +
  tm_shape(outlier_sf) +
  tm_borders(col = "red", lwd = 2)
```

```{r}
tmap_mode("plot")
```

The interactive map above is far from satisfactory. While we want to encourage users to engage and explore the interactive by zooming in and out of the study area freely. But, users might lost in the cyberspace with too much freedom to zoom-in and zoom-out.

To address this issue,Â `set_zoom_limits`Â argument can be used to limit the map extend users can zooming in and out of the map areas as shown below.

```{r}
region_selected <- mpsz_pop2024 %>%
  filter(REGION_N == "CENTRAL REGION")
region_bbox <- st_bbox(region_selected)

stats <- boxplot.stats(region_selected$DEPENDENCY)
outlier_vals <- stats$out
outlier_sf <- region_selected[region_selected$DEPENDENCY %in% outlier_vals, ]

tmap_mode("view")

tm_shape(region_selected, 
         bbox = region_bbox) +
  tm_fill("DEPENDENCY",
          id = "SUBZONE_N",
          popup.vars = c(
            "Name" = "SUBZONE_N", 
            "Dependency" = "DEPENDENCY")) +
  tm_borders() +
  tm_shape(outlier_sf) +
  tm_borders(col = "red", lwd = 2) +
  tm_view(set_zoom_limits = c(12,14))
```

```{r}
tmap_mode("plot")
```

## **2.9Â Reference**

### **2.9.1Â All aboutÂ tmapÂ package**

-   [tmap: Thematic Maps in R](https://www.jstatsoft.org/article/view/v084i06)

-   [tmap](https://cran.r-project.org/web/packages/tmap/index.html)

-   [tmap: get started!](https://cran.r-project.org/web/packages/tmap/vignettes/tmap-getstarted.html)

-   [tmap: changes in version 2.0](https://cran.r-project.org/web/packages/tmap/vignettes/tmap-changes-v2.html)

-   [tmap: creating thematic maps in a flexible way (useR!2015)](http://von-tijn.nl/tijn/research/presentations/tmap_user2015.pdf)

-   [Exploring and presenting maps with tmap (useR!2017)](http://von-tijn.nl/tijn/research/presentations/tmap_user2017.pdf)

### **2.9.2Â Geospatial data wrangling**

-   [sf: Simple Features for R](https://cran.r-project.org/web/packages/sf/index.html)

-   [Simple Features for R: StandardizedSupport for Spatial Vector Data](https://journal.r-project.org/archive/2018/RJ-2018-009/RJ-2018-009.pdf)

-   [Reading, Writing and Converting Simple Features](https://cran.r-project.org/web/packages/sf/vignettes/sf2.html)

### **2.9.3Â Data wrangling**

-   [dplyr](https://dplyr.tidyverse.org/)

-   [Tidy data](https://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html)

-   [tidyr: Easily Tidy Data with â€˜spread()â€™ and â€˜gather()â€™ Functions](https://cran.r-project.org/web/packages/tidyr/tidyr.pdf)

### 2.9.4

Kam, K. (2022). *Thematic Mapping and GeoVisualisation with R*. R4GDSA Lecture Notes, Chapter 2.
